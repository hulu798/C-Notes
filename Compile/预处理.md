# 预处理过程

![image-20250804113504573](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804113510056.png)

```c
// preprocessing_demo.c
#include <stdio.h>

// 简单宏定义
#define PI 3.14159
#define VERSION 2
#define AUTHOR "Claude"

// 函数式宏
#define SQUARE(x) ((x) * (x))
#define DEBUG_PRINT(msg) printf("[DEBUG] %s:%d - %s\n", __FILE__, __LINE__, msg)

// 条件编译
#define ENABLE_LOGGING 1

#if VERSION >= 2
    #define FEATURE_ADVANCED
#endif

int main() {
    printf("=== 预处理演示 ===\n\n");
    
    // 1. 简单宏替换
    printf("PI 的值: %.5f\n", PI);
    printf("圆的面积 (r=5): %.2f\n", PI * 5 * 5);
    
    // 2. 函数式宏
    int num = 7;
    printf("SQUARE(%d) = %d\n", num, SQUARE(num));
    
    // 3. 预定义宏
    printf("\n=== 预定义宏信息 ===\n");
    printf("文件名: %s\n", __FILE__);
    printf("当前行: %d\n", __LINE__);
    printf("编译日期: %s\n", __DATE__);
    printf("编译时间: %s\n", __TIME__);
    printf("函数名: %s\n", __func__);
    
    // 4. 条件编译
#ifdef FEATURE_ADVANCED
    printf("\n高级功能已启用 (版本 %d)\n", VERSION);
#endif

#if ENABLE_LOGGING
    DEBUG_PRINT("程序运行中...");
#endif

    // 5. 字符串化和连接
    #define STR(x) #x
    #define CONCAT(a, b) a##b
    
    printf("\n=== 字符串化和连接 ===\n");
    printf("STR(VERSION): %s\n", STR(VERSION));
    
    int CONCAT(var, 123) = 456;
    printf("var123 的值: %d\n", var123);
    
    printf("\n程序作者: %s\n", AUTHOR);
    
    return 0;
}
```



# 预定义符号

C语言设置了一些预定义符号，可以直接使用，预定义符号也是在预处理期间处理的

```c
__FILE__ //进行编译的源文件名称
__LINE__ //当前行号
__DATE__ //日期
__TIME__ //当前时间
__STDC__ //如果编译器遵循ANSI C,其值为1,否则未定义
```

==示例==

![image-20250804114917279](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804114917380.png)

==其他预定义符号==

![image-20250804115131947](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804115137437.png)

利用上面的预定义符号配合条件可以很好的解决跨平台的问题



# `#define`定义宏(macro)

```c
//简单宏定义
#define name stuff
```



```c
//函数式宏定义
#define name( parament-list ) stuff
```

> [!warning]
>
> 参数列表的左括号必须与name紧邻，如果两者之间有任何空白存在，参数列表就会被解释为stuff的
> 一部分

比如

```c
#define add (x,y) ((x)+(y)) //add与(x,y)之间有空格,不会当成函数式宏而报错
```



```c
//offsetof实现
#define offsetof(type,member) ((size_t)(&((type*)0)->member))
```



# #和##

## #运算符

![image-20250804133041709](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804133041780.png)

## ##运算符

![image-20250804133224773](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804133224835.png)

# #undef

这条指令用于移除一个宏定义

```c
#define MAX 100

#undef MAX //移除MAX定义后不能再使用了
```

# 命令行定义

![image-20250804133509846](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804133509910.png)

# 条件编译

在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令

![image-20250804134003724](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804134003784.png)

# `#pragma`

- `#pragme message`

	![image-20250804134856627](https://gitee.com/hulu135289/Typora/raw/master/img-mac/20250804134856683.png)

- `#pragma once`只要在头文件的最开始加入这条指令就能够保证头文件被包含一次

	```c
	//file.h
	#pragma once 
	
	#include<stdio.h>
	#include<stdlib.h>...  //在头文件开头加上#pragma once可以防止头文件多次包含,主要只能用于头文件而且放在开头
	```

- `#pragma pack()`改变默认对齐数(内存对齐)
