# ` static`

`static`本意是静态的意思,用static修饰标识符可以让标识符由存储位置由堆栈区转到静态区,我们都知道栈区存储的是自动变量(局部变量和函数形参),会自动分配和释放内存,具有局部作用域,而堆区内存动态分配,手动释放,静态区的变量生命周期延长至整个程序结束才销毁释放内存,用`static`修饰标识符可以延长标识符的生命周期

- 用`static`修饰局部变量可以延长变量的生命周期,但是作用域不变,还是只能进入变量作用域才能访问,但是由于存储在静态区,变量的值会保存,即**每次进入变量的作用域会保留上一次变量的值,且初始化只会初始化一次**,因为静态变量定义是在编译阶段执行的,在编译阶段已经初始化了,后续会跳过变量的定义语句

<img src="https://gitee.com/hulu135289/Typora/raw/master/img/20250426104522900.png" alt="image-20250426104515419" style="zoom:50%;" />

> 此处用`static`修饰局部变量a,让a变为静态变量,在编译阶段就会指向`int a=1;`这条语句,此后每次调用函数都不会执行,即使只初始化一次,而且是在编译阶段(调试可以发现会直接跳过这条语句,可以验证在编译阶段执行),由于存储在静态区,会保留a的值,从而输出1 2 3 4 5

![image-20250426110645934](https://gitee.com/hulu135289/Typora/raw/master/img/20250426110646048.png)

- `static`修饰全局变量&修饰函数

	用`static`修饰具有文件作用域的变量,**如果本身标识符具有外部链接属性**,会使其链接属性由external变为internal,其他源文件不能引用这个标识符,比如**全局变量和函数**,用`static`修饰后不再具有外部链接属性,生命周期保持不变(还是存储在静态区)

**总结**:`static`修饰局部变量和全局变量效果不同,一个是改变存储位置进而改变生命周期,一个是改变链接属性



> [!warning]
>
> `static`修饰的变量初始化只能是常量,因为`static`修饰的变量在编译阶段创建
>
> ![image-20250718002441639](https://gitee.com/hulu135289/Typora/raw/master/img/20250718002448841.png)

# `extern`声明来自外部的符号

注意声明来自外部的符号用`extern,`但是这个**标识符需要有外部链接属性**,示例:

```c
//add.c文件
int add(int x,int y)
{
    return x+y;
}

//main.c
#include<stdio.h>
extern int add(int,int ); //int add(int ,int);也可以
int main()
{
    printf("%d\n",add(10,20));
}
```

> [!tip]
>
> 其他源文件使用具有外部链接属性的标识符的时候需要==`extern`+完整声明==,不过通常来说函数在其他源文件使用的时候只需要声明函数类型即可,不必加`extern`,但是变量必须加`extern`
>
> ```c
> //源文件1:
> int a=20;
> 
> //源文件2:使用变量a
> extern int a;
> ```

> [!warning]
>
> 使用`extern`声明外部符号`extern`+完整声明,这里完整声明需要与其他文件改符号的声明一致:
>
> ![image-20250720175417741](https://gitee.com/hulu135289/Typora/raw/master/img/20250720175424894.png)
>
> 此处`file1.c`的`arr`是数组,而`file2.c`的`arr`是指针,尽管数组名在除`sizeof`和`&`以外的情况会退化为首元素的指针,但是数组和指针不是一样的类型,具体原因与`extern`有关

![6e031841-f9a6-42fe-bb39-f6a2abf006c9(1)](https://gitee.com/hulu135289/Typora/raw/master/img/20250720214742865.png)

使用`extern`声明外部符号在链接的时候会对照符号表,但是只是对照标识符的名字而不会匹配类型,C语言在编译和汇编的时候是单独处理每个文件的,最后在链接的时候汇总符号表,如果`extern`声明的外部符号在其他源文件有对应的标识符且类型相同,这个时候会合并标识符符号,属于正常的用法

如果其他源文件没有`extern`声明的标识符,会出现链接错误(链接的时候会合并对照符号表,发现`extern`声明的标识符在其他源文件没有标识符链接错误)

如果其他源文件也有这个标识符但是类型不同,这个时候不会发生链接错误,因为链接的时候编译器只会检查标识符的名字是否相同,如果类型不相同但是符号表在不同文件中又有相应的标识符名字(**不同源文件出现标识符都会记录在符号表,如果类型和名字相同,在链接的时候合并,类型不同不会合并,此时相当于重新定义了一个标识符,且初始化为0**)

示例:

```c
//file1.c
int value=10;

//file2.c
extern double value;
printf("%f\n",value); //输出0.000000
```

> **`extern`总结**
>
> - `extern`声明的标识符在其他源文件也有且类型相同,正常使用
> - `extern`声明的标识符其他源文件没有,链接错误
> - `extern`声明的标识符其他源文件有但类型不同,此时`extern`声明的标识符起到定义标识符的作用且初始化为0(相当于全局变量初始化wei)
