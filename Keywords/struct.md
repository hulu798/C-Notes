# 结构体

## 概念

c语言中用于定义和描述复杂对象的表示方式,用关键字`struct`定义结构体对象,在处理复杂数据类型十分有优势它可以将不同类型的变量组合在一起，使数据的组织更加灵活高效。结构体常用于定义复杂的数据模型，如学生信息、点坐标等

### 定义基本结构体

```c
最基本的定义方式
struct 结构体名   //是结构体的类型名称,以后需要定义结构体变量需要使用这个结构体名
{
    数据类型 成员1;    //比如int year;
    数据类型 成员2; 	  //注意C语言结构体的定义不允许初始化,只有使用这个结构体定义去定义结构体变量的时候才允许初始化      
    ...
};  //不要遗漏分号结尾
```

> 可以使用`sizeof`求出结构体的大小,其大小为里面每个成员的大小之和(其实定义一个结构体等价于定义里面每一个成员)

示例

```c
struct Student {
    int id;          // 学号
    char name[50];   // 姓名
    float score;     // 成绩
};     
```

定义好结构体后便可以后续定义结构体变量使用这个结构体
```c
struct Student A;   //仅仅定义结构体变量,不初始化;
struct Student B={123456,"小明",100.0};  //定义的同时初始化结构体变量
struct Student C={.id=123456,.name="小红",.score=100.0};
```

### 定义的同时定义结构体变量

在定义结构体最后加上需要定义的结构体变量,可以一次性解决结构体的定义和结构体变量的定义
```c
struct Student {
    int id;          // 学号
    char name[50];   // 姓名
    float score;     // 成绩
}a,b,c;   //定义a,b,c三个 struct Student类型结构体变量  


//这样也是正确的
struct Student {
    int id;          // 学号
    char name[50];   // 姓名
    float score;     // 成绩
}a,b,c,arr[50],d={.id=123,.name="hello world",.score=20}; //定义的同时初始化
```



### 缺省型结构体的定义

指的是在定义结构体的时候不给结构体命名,这个时候由于结构体没有名,不可以在之后定义该类型的结构体变量,所以使用缺省型结构体的定义只能按照上面定义结构体的同时定义结构体变量,只有这种结构体只需要使用一次的时候才会使用这种方式,比较鸡肋

### `typedef`定义和给结构体其别名

由于基础版本的结构体定义在之后使用这个结构体来创建结构体变量的时候每次都需要加上关键字`struct`有点多余,从而推荐使用typedef修饰结构体定义,使其后续定义结构体变量的时候可以省略加上关键字`struct`

```c
typedef struct StructName
{
    数据类型 成员名1;
    数据类型 成员名2;
    数据类型 成员名3;
    ...
}newName;   //在末尾给结构体取别名,后续就可以使用这个别名定义结构体变量比如new Name arr[20];定义newName类型的结构体数组
```

> [!tip]
>
> - 采用typedef定义结构体可以使用缺省型的结构体定义(即可省略`StructName`),因为我们在后续可以通过别名来定义结构体变量,如果不省略结构体名只是多一种方法来定义结构体变量罢了,不过这个多的方法需要加`struct`$:$`srutct StructName arr[20]`😢
> - **==易错提醒==**
>
> ```c
> typedef struct StructName
> {
>     数据类型 成员名1;
>     数据类型 成员名2;
>     数据类型 成员名3;
>     ...
> }a,b,c;  //这个时候不是定义a,b,c三个结构体,而是定义a b;a c;两个结构体变量,因为前面有typedef修饰,最后的a表示结构体的别名,后面两个才是定义的结构体变量,不建议使用这个方式定义,但是遇到这种写法需要看懂什么意思
> ```







### 初始化结构体变量

> **对定义的结构体变量初始化注意点:**
> 	**定义结构体变量后相当于定义了之前定义的结构体内的全部数据类型**,**定义的同时可以初始化**,初始化方式和对应内部数据类型的初始化方式相同(比如`id`这个数据类型直接在初始化为123456即可,字符型数组初始化为`"小明"`),用`{}`内部按结构体数据定义的顺序初始化(这个赋值方式仅限于初始化,如果结构体变量已经定义了,就不能再用这个方法初始化了)
> 	**指定成员初始化(也是限于定义结构体变量的同时初始化,定义好了就不能用这个方式赋值了)**
> 用`.`＋成员名赋值的方式初始化,这个时候吧`.+成员名`看出刚刚定义好的变量,现在即对这个变量初始化,比如上面的`.name`是字符型数组,可以直接把字符串赋值给它,和字符型数组定义的同时可赋值完全一致

### 访问结构体变量成员

> **定义好结构体变量后如何对成员赋值**
> 	使用`.`运算符可以访问结构体变量的成员
>
> ```c
> Student A; //定义结构体变量
> A.score=90.0;  //使用`.`访问结构体成员
> ```
>

### 嵌套结构体定义与访问

结构体允许嵌套定义,从而可以构成更加复杂的结构体,表示复杂的类型

示例代码

```c
struct Address {
    char city[50];
    char street[50];
};
 
struct Student {
    int id;
    char name[50];
    struct Address addr; // 嵌套 Address 结构体
};
 
int main() {
    struct Student s1 = {1, "Alice", {"New York", "5th Avenue"}};
    printf("City: %s\n", s1.addr.city);
    printf("Street: %s\n", s1.addr.street);
    return 0;
}
```

> [!important]
>
> - 对嵌套结构体变量初始化可以大括号里面嵌套大括号对成员也是结构体的嵌套结构体变量初始化
> - 访问嵌套结构体成员时候仍然使用`.`访问,只是如果成员也是结构体,这个时候可以再次用`.`对其访问(如上面15行) 

## 使用已定义的结构体

### 结构体数组

通过已经定义的结构体我们可以定义结构体数组(甚至是结构体多维数组),**我们把结构体看成一种新的数据类型就好了**

```c
struct Student class[50]; //定义结构体数组,里面每个元素都是结构体变量,从而可以建立一个班级的全部学生
```

此外我们**使用结构体数组进行元素互换操作会把里的结构体变量交换**,比如说对学生成绩排名,使用排序法进行排序,比较的是`arr[i].score`,但是实际交换的时候我们交换数组的元素,这个时候会把整个结构体变量交换,可见方便了很多

## 结构体指针

> 与普通的指针类型差不多,只不过指向的数据类型是自定义类型,类似数组下标运算符,结构体指针有结构指针运算符(`->`)直接由指针访问结构体成员

## 结构体自引用

结构体在定义的同时成员可以该类型结构体指针,注意成员不能是结构体本身,否则造成无限递归报错

```c
//链表节点
sturct Node
{
    int data;
    sturct Node *next;
};
```

> [!warning]
>
> 匿名结构体定义不能使用结构体自引用
>
> ```c
> //错误示例
> typedef struct
> {
>        int data;
>        Node *next;
> }Node;
> 
> //正确示例
> typedef struct Node
> {
>        int data;
>        struct Node *next;
> }Node;
> ```
>
> ![image-20250607160214370](https://gitee.com/hulu135289/Typora/raw/master/img/20250607160221545.png)



## 柔性数组($Flexible\ Array\ Member$)

> 在 C 语言中，柔性数组（$Flexible Array Member$,简称$ FAM$）是一种特殊的数组成员，通常用于结构体中，允许结构体包含一个大小可变的数组。它在$ C99$ 标准中引入，主要用于动态分配内存以存储变长数据

![image-20250603181130850](https://gitee.com/hulu135289/Typora/raw/master/img/20250603181131494.png)

> [!warning]
>
> - 柔性数组必须在结构体最后成员才能使用,而且结构体不止这一个成员
> - 含有柔性数组的结构体`sizeof`计算大小的时候柔性数组大小算作0
> - 含有柔性数组的结构体使用动态内存分配开辟空间
>
> ```c
> typedef struct
> {
>     char a;
>     char arr[];
> }Test;
> Test *p=malloc(sizeof(struct)+sizeof(char)*len);
> ```
>
> - 柔性数组开辟空间的时候也需要遵循内存对齐,需要把元素存储在对齐数的倍数的位置.
>
> ```c
> typedef struct
> {
>     short value;
>     int arr[];
> }Test;
> 
> int main()
> {
>     Test *p=malloc(sizeof(Test)+sizeof(int)*2);
>     printf("%p\n",p);
>     printf("%p\n",p->arr);
>     return 0;
> }
> //打印的地址相差4说明开辟arr内存的时候不是直接在short后面开辟,会空两个满足对齐数.
> ```
>
> - 使用柔性数组方便改变长度,使用`realloc`可以动态改变数组大小

## 内存对齐

### 对齐规则

1. 结构体的第1个成员对齐到和结构体变量起始位置偏移量为0的地址处(==偏移量为0是任意对齐数的整数倍==)

2. 从第2个成员变量开始,都要对齐到对齐数的整数倍的地址处

  对齐数 = 编译器默认的⼀个对齐数与该成员变量大小的较小值

  - `VS `中默认的值为 8

  - `Linux`中` gcc `没有默认对齐数,对齐数就是成员自身的大小

  - `#pragra`预处理指令设置默认对齐数

3. **结构体总大小为最大对齐数**（结构体中每个成员变量都有⼀个对齐数，所有对齐数中最大的与编译器默认对齐数的较小值$min\{默认对齐数,每个成员对齐数最大值\}$）的整数倍

4. 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍

5. 数组成员对齐数为数组元素的大小

```c
// 练习1
struct S1
{
    char c1;
    int i;
    char c2;
};
printf("%d\n", sizeof(struct S1)); //12
// 练习2
struct S2
{
    char c1;
    char c2;
    int i;
};
printf("%d\n", sizeof(struct S2)); //8
// 练习3
struct S3
{
    double d;
    char c;
    int i;
};
printf("%d\n", sizeof(struct S3)); //16
// 练习4-结构体嵌套问题
struct S4
{
    char c1;
    struct S3 s3;
    double d;
};
printf("%d\n", sizeof(struct S4)); //32
```

### `offsetof`

查看结构体成员在内存中存储方式使用宏`offsetof`

![image-20250607163446780](https://gitee.com/hulu135289/Typora/raw/master/img/20250607163447069.png)

```c
typedef struct 
{
    char a;
    int b;
    double c;
}Test;
printf("%zu %zu %zu",offsetof(Test,a),offsetof(Test,b),offsetof(Test,c));
//输出每个成员地址相对于结构体起始地址的偏移量
```

### 内存对齐的普遍性

![image-20250607170429294](https://gitee.com/hulu135289/Typora/raw/master/img/20250607170429819.png)

> 对于结构体,成员存在内存对齐同时,定义结构体变量的时候,变量也会内存对齐,对齐规则取决于结构体成员最大对齐数,比如一个结构体其成员最大对齐数是8,则这个结构体变量地址只能是8的倍数
>
> ![image-20250607170941026](https://gitee.com/hulu135289/Typora/raw/master/img/20250607170941242.png)
>
> **注:**实际上结构体成员按照对齐规则后,变量也对齐,最后每个成员的地址也满足内存对齐,结构体内存对齐规则实际上是从普通数据内存对齐得到的,从中不难理解为什么嵌套结构体内层结构体需要对齐其成员最大对齐数,都是为了保证每一个元素的地址都是对齐数的倍数

### 内存对齐原因

![image-20250607173354796](https://gitee.com/hulu135289/Typora/raw/master/img/20250607173356052.png)

> 对齐原因:处理器处理数据的时候以单字(4个字节,32位,x86)或者双字(8个字节,64位,x64)为单位,数据在内存对齐中对齐可以防止被切割在两个字里面(字节数小于等于8的时候)或者被切割在更多的字节里面,如16个字节的数据内存对齐可以一次性被x64处理器处理或者两次被x86处理器处理,但是如果没有对齐就有可能分配在3个字里,这个时候效率降低了![image-20250607174330054](https://gitee.com/hulu135289/Typora/raw/master/img/20250607174330279.png)

### 修改结构体默认对齐数

> 使用预处理指令`#pragma`,可以改变编译器的默认对齐数,如果原来没有默认对齐数,则会加上默认对齐数,使得在数据对齐数和默认对齐数中选择更小的进行对齐

```c
#include <stdio.h>
#pragma pack(1) // 设置默认对⻬数为1
struct S
{
    char c1;
    int i;
    char c2;
};
#pragma pack() // 取消设置的对⻬数，还原为默认
int main()
{
    // 输出的结果是什么？
    printf("%d\n", sizeof(struct S));
    return 0;
}
```

## 结构体传参

> 与普通变量一样,自定义类型结构体也可以作为参数给含传参,而且与普通变量一样,传参的时候会在函数栈帧上创建临时变量把结构体变量拷贝过去,这个时候就会出现传址和传值的选择

```c
struct S
{
    int data[1000];
    int num;
};
struct S s = {{1, 2, 3, 4}, 1000};
// 结构体传参
void print1(struct S s)
{
    printf("%d\n", s.num);
}
// 结构体地址传参
void print2(struct S *ps)
{
    printf("%d\n", ps->num);
}
int main()
{
    print1(s);  // 传结构体
    print2(&s); // 传地址
    return 0;
}
```

> 上⾯的 print1 和 print2 函数哪个好些？
>
> 答案是：⾸选print2函数,传址调用,避免创建零时结构体变量,结构体S大小为4004占用很大内存压栈会造成很大的开销,优先选择传址调用

## 结构体位段

### 位段概念

> 在C语言中，结构体位段（Bit Field）是一种特殊的结构体成员，用于在结构体中以位（bit）为单位分配内存，而不是以字节（byte）为单位。这允许更高效地控制内存使用，尤其在需要存储大量标志或小型整数时

```c
struct 结构体名 {
    类型 成员名 : 位宽;
};
```

- 类型：通常是整数类型，如 `int`、`unsigned int` 或 `char`。C标准允许实现定义支持的其他类型，但最常用的是整数类型(只允许整形家族使用位段`int,char,short...`)
- 位宽：为该成员分配的比特位,必须是非负整数，且不能超过该类型的总位数(如`int`类型使用位段位宽范围是0~32)

```c
//位段示例
struct A
{
    int _a:2;
    int _b:5;
    int _c:10;
    int _d:30;
};
```

### 位段的内存分配

- 位段的成员可以是 `int` `unsigned int` `short` 或者是 `char `等整形家族类型
- 位段的空间上是按照需要`sizeof(int)`,`sizeof(unsigned int)` `sizeof(short)` `sizeof(char)`来开辟的
- 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段

下面分析位段内存分配和使用

```c
struct S
{
    char a:3;
    char b:4;
    char c:5;
    char d:4;
};

struct S s = {0};
s.a = 10;
s.b = 12;
s.c = 3;
s.d = 4;
```

> 首先第一个成员`a`是`char`类型,按照`sizeof(char)`开辟空间存储`a`,这一个字节中`a`只占用三个比特位,至于是前三个还是后三个取决于平台,然后考虑`b`,`b`需要占用4个比特位,上面`a`的一个字节剩余5个比特位可以存储`b`所以不会额外开辟内存存储`b`了,考虑`c`,需要占用5个比特位,但是上面开辟只剩下1给比特位,所以会按照`c`的类型再次开辟内存空间,一次性开辟`sizeof(char)`个字节(取决于`c`的类型),然后再存放`c`,==注意:上一次剩下的比特位放不下需要新开辟内存这种情况下,把数据存储进内存上一次剩下的内存是否使用是取决于平台的==,为`c`开辟1个字节内存后假设上面剩下的1个bit不使用,此时占用5个bit剩余3个,考虑`d`,需要占用4个bit但是只剩余3个,所以需要再次开辟内存,大小取决于`d`类型,再存储`d`,以上就是对位段内存分配的分析

![image-20250610230348505](https://gitee.com/hulu135289/Typora/raw/master/img/20250610230355892.png)

![image-20250610231306746](https://gitee.com/hulu135289/Typora/raw/master/img/20250610231307413.png)

我们可以发现`GCC`编译器下

- 使用一个字节是从右往左
- 位段开辟新的字节情况下,上一次未用完的比特位不再使用

### 位段使用的注意事项

> 位段的几个成员共有同一个字节，这样有些成员的起始位置并不是某个字节的起始位置，那么这些位置处是没有地址的。内存中每个字节分配一个地址，一个字节内部的bit位是没有地址的。所以不能对位段的成员使用`&`操作符，这样就不能使用`scanf`直接给位段的成员输入值，只能是先输入放在一个变量中，然后赋值给位段的成员。

```c
struct A
{
    int _a : 2;
    int _b : 5;
    int _c : 10;
    int _d : 30;
};
int main()
{
    struct A sa = {0};
    scanf("%d", &sa._b); // 这是错误的
    // 正确的示范
    int b = 0;
    scanf("%d", &b);
    sa._b = b;
    return 0;
}
```

