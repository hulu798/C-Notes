[TOC]



# 数组

## 访问数组运算符

```c
int arr[10];
arr[4];  //访问数组第五个元素
int* p1=arr;
p1[4];   //访问数组第五个元素
int* p2=&arr[2]; //p2=arr+2
p2[4];   //访问第七个元素  p2[4]=*(p2+4)
```

> [!important]
>
> C语言中`arr[4]`相当于`*(arr+4)`,数组名等于首元素地址,而访问数组运算符运算是`*(arr+4)`,把数组名赋值给指针,对指针进行访问数组运算符操作结果相同,但是对指针进行访问数组运算符更灵活

## 字符数组

### 从输入流读取字符串到字符数组

`scanf,gets,fgets`等函数从`stdin`读取字符串到字符数组会自动在末尾加上`'\0'`表示字符串结束,即使数组已经越界也会加上这个字符串结束标志,因为C语言编译器不会检查数组是否越界,还是会按照正常方式在末尾加上`\0`,**但是在在线OJ平台会检查数组越界,或者越界部分禁止访问,所以需要注意数组越界的问题**



`printf`在打印字符串的时候遇到'\0'会结束打印,因为'\0'被认为是字符串结束的标志

C语言字符串长度定义是一串字符中所有字符的格式,并以第一个'\0'为结束标志(字符串长度不包括'\0')

```c
char arr[]="hello\0world";//字符串长度为5,总共有两个\0(双引号表示的字符串结尾默认有\0)
```

>字符数组初始化:
>在 C 语言里，当使用初始化列表对数组进行初始化，且初始化列表中的元素数量少于数组定义的大小时，数组中剩余未被显式赋值的元素会被自动初始化为对应类型的默认值(隐式初始化为'\0')。对于字符类型（char），默认值是 '\0'（ASCII 码值为 0），也就是字符串结束符

结合上面的特点

```c
char arr[20]="hello";
printf("%zd\n",strlen(arr));//输出5,因为遇到'\0'会认为字符串结束
```



## 数组传参

数组在函数中传参会退化成首元素的指针

比如说

```c
void fun(int arr[])
```

传参数组和这个等价

```c
void fun(int* arr)
```

但是注意

```c
void fun(int* arr[])
//这个与上面不一样,这个意思是传递指针类型数组,即一个数组全部是指向int的指针,小心不要用错
```



##### ==**二维数组传参**==

在函数声明和定义时明确指定二维数组的列数，但行数可以不指定

```c
#include <stdio.h>

// 函数定义，指定二维数组的列数
void printArray(int arr[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    // 调用函数并传递二维数组
    printArray(arr, 2);
    return 0;
}
```

1. **解释**：

- 在函数 `printArray` 中，`int arr[][3]` 表示接收一个二维数组，虽然行数未指定，但列数必须明确为 3。这是因为编译器需要知道每一行元素的个数，以便进行内存寻址和访问。
- 在 `main` 函数中，将二维数组 `arr` 传递给 `printArray` 函数，同时传递行数 2。



## 指针与数组

```c
#include <stdio.h>

int main() {
    // 定义一个包含 5 个元素的一维数组
    int arr[5] = {1, 2, 3, 4, 5};
    // 定义一个指向包含 5 个元素的一维数组的指针
    int (*ptr)[5];
    // 让指针指向数组
    ptr = &arr;
    // 通过指针访问数组元素
    for (int i = 0; i < 5; i++) {
        printf("%d ", (*ptr)[i]);
    }
    printf("\n");
    return 0;
}
```



指向整个数组的指针:

```markdown
数组名已经代表了数组首元素的地址,如果这个时候取&arr,这个时候得到是整个数组的地址(指向整个数组),如果这个时候&arr+1得到的地址已经越界了(偏移量是整个数组),因为指向整个数组,+1就越过了数组
即arr和&arr值相同,但是arr指向数组首元素的地址,&arr指向整个数组的地址,其值为数组首元素的地址
```

### 一维数组

> [!tip]
>
> 一维数组数组名代表首元素的地址(例外:`sizeof(array)`和`&array`)

下面运行结果都相同但是偏移量不同

![image-20250306230357592](https://gitee.com/hulu135289/Typora/raw/master/img/20250306230404782.png)

```c
int arr[10];
int* p=&arr[0]+1;   //得到是下一个元素地址,而不是偏移量为1的地址
//如果想偏移量加1需要强制类型转换:
(char*)&arr[0]+1;
```

类似的,给某个元素地址+1偏移量是这个元素占用内存的大小,比如说

```c
int a=10;
int* p=&a+1; //得到a元素地址+4
```

### 二维数组

> [!warning]
>
> 二维数组的数组名代表一维数组,其值等于首元素的地址:即一个指向数组的指针⭐⭐⭐

==**二维数组名:**==

> [!important]
>
> 二维数组名代表首行地址,用数组指针接收

```c
int arr[2][3];
int (*p)[3]=arr;   //意思是一个指针指向含有三个int类型数据的数组,而arr数组名字恰好代表首行数组的地址
但是注意区分
int (*p)[3];
int* p[3];
//前者代表一个指向数组的指针变量,后者代表声明一个指针数组,里面元素类型是指针变量⭐⭐⭐
```

```c
前面提到数组名+&代表整个数组的地址,这个时候用数组指针接收这个地址即可
int arr[10];
int (*p)[10]=&arr;     //注意这里数组指针长度必须与数组长度一致
```



<font size=5>==**计算二维数组行数**==</font>

二维数组`arr`,如果<font color="red">只有一个[ ]代表某行数组</font>,进而退化成每行首元素的地址

```c
int arr[x][y];
int row=sizeof(arr)/sizeof(arr[x]); //这里计算整个数组的大小除以一行的大小等于行数
int colmn=sizeof(arr[0])/sizeof(arr[0][0]);   //这里计算一行大小除以一个大小等于列数
```

### 用指针表示数组

访问对象操作符`arr[i]`等价于`*(arr+i)`从而可以用指针表示数组和对数组进行操作

#### 一维数组

数组名代表首元素地址,用`*(arr+i)`来访问数组元素,和正常数组访问基本一致

#### ==二维数组及多维数组==

讲解二维数组

==二维数组首元素地址代表的是一维数组,代表首元素的地址,但是二维数组是以一维数组为元素的数组==

```c
int arr[10][10];
int (*ptr)[10]=arr;  //二维数组名代表一维数组的地址,用数组指针接收这个值,然后访问arr数组的时候,arr里面的元素都是一维数组的首元素地址(一维数组数组名代表首元素的地址)
(*(ptr+3)+3)=6;//把数组第四行第四列赋值为6
//等价于
ptr[3][3]=6;  //由于访问对象操作符和指针解引用等价
```

对于更多维数组也可以这样理解,$n$维数组的元素是$n-1$维数组,然后递归拆解即可,需要注意的是$n$维数组元素是$n-1$维数组,所以访问$n$维数组元素的时候需要对其解引用(相当于访问一维数组元素需要对一维数组解引用`&(arr+1)`),进一步解引用才能降维访问下一维的元素,需要$n$次解引用才能访问真正的数组元素

```c
//多维数组示例
#include <stdio.h>

int main()
{
    int arr[2][3][4] = {1, 2, 3, 4,
                        5, 6, 7, 8,
                        9, 10, 11, 12,

                        13, 123, 31, 23,
                        4, 342, 53, 45,
                        234, 54, 43, 67};
    int (*ptr)[2][3][4] = &arr;
    printf("%d\n", *(*(*(*ptr+1)+2)+3));
    return 0;
}
```

> 这里定义三维数组,用指针访问三维数组元素:
>
> 定义指针`int (*ptr)[2][3][4] = &arr;`,这里补充$:$对数组名取地址得到指向整个数组的地址,比如说对一维数组取地址赋值给一个数组指针,这个时候这个指针指向整个数组,步长为整个的数组大小
> 取地址相当于升维,而解引用相当于降维
>
> 这里定义一个指针指向这个三维数组,然后访问三维数组的元素:
> 对`ptr`解引用,这个时候`*ptr`指向三维数组首元素的地址(对`ptr`解引用相当于`*ptr=arr`,把三维数组数组赋值给`*ptr`),这个时候`*ptr`指向的是二维数组,在通过`*ptr+i`确定访问哪一个二维数组,再解引用二维数组赋值给`*(*ptr+1)`,此时指向的是一个一维数组(二维数组的元素),进一步解引用得到指针的值是一维数组,即一维数组首元素的地址,解引用即可得到访问的元素,<font color="red">等价于`(*ptr)[1][2][3]`</font>



**==上面对三维数组取地址操作不是必要的,用指针操作多维数组如下:==**

```c
#include <stdio.h>
int main()
{
    int arr[2][3][4] = {1, 2, 3, 4,
                        5, 6, 7, 8,
                        9, 10, 11, 12,
                        13, 123, 31, 23,
                        4, 342, 53, 45,
                        234, 54, 43, 67};
    int (*ptr)[3][4] = arr;
    printf("%d\n", ptr[1][2][3]); //用二维指针数组访问三维数组的元素,相当于用普通指针访问一维数组元素
    return 0;
}
```



#### 多维数组与多级指针

**==注意多维数组的数组名不是n维指针而是一个数组指针,即指向数组的指针==**

##### 核心结论

- 对于一个n维数组，数组名在大多数情况下会退化为**指向其第一个元素的指针**，而第一个元素的类型决定了指针的级别。

##### 详细解释

1. **数组名退化规则**：

   - 在C语言中，数组名（如 `arr`）在表达式中通常退化为指向其第一个元素的指针（除非用在 `sizeof` 或取地址 `&arr` 的情况下）。
   - 对于多维数组，数组的“第一个元素”本身可能是一个低维数组，因此需要逐步分析。

2. **逐维度分析**：
   - **一维数组**：

     ```c
     int arr[5];
     ```

     - `arr` 是一个一维数组，类型是 `int[5]`。
     - 第一个元素是 `arr[0]`，类型是 `int`。
     - `arr` 退化为指向 `arr[0]` 的指针，即 `int *`（一级指针）。

   - **二维数组**：

     ```c
     int arr[3][4];
     ```

     - `arr` 是一个二维数组，类型是 `int[3][4]`。
     - 第一个元素是 `arr[0]`，类型是 `int[4]`（一个一维数组）。
     - `arr` 退化为指向 `arr[0]` 的指针，即 `int (*)[4]`（指向一维数组的指针，仍然是一级指针，但指向的是一维数组）。
     - 注意：`int (*)[4]` 不是 `int **`，是一级数组指针,不是二级指针

   - **三维数组**：

     ```c
     int arr[2][3][4];
     ```

     - `arr` 是一个三维数组，类型是 `int[2][3][4]`。
     - 第一个元素是 `arr[0]`，类型是 `int[3][4]`（一个二维数组）。
     - `arr` 退化为指向 `arr[0]` 的指针，即 `int (*)[3][4]`（指向二维数组的指针，仍然是一级指针）。
     - 依此类推。

   - **n维数组**：
     - 对于一个n维数组 `int arr[d1][d2][d3]...[dn]`：
       - 第一个元素是 `arr[0]`，类型是 `int[d2][d3]...[dn]`（一个(n-1)维数组）。
       - `arr` 退化为指向 `arr[0]` 的指针，即 `int (*)[d2][d3]...[dn]`。
       - 这是一个一级指针，指向一个(n-1)维数组。
       - 如果继续分析 `arr[0]`，它会退化为指向其第一个元素的指针，即 `int (*)[d3]...[dn]`（指向(n-2)维数组的指针），以此类推。

3. **与指针数组的区别**：
   - 如果是**指针数组**（如 `char *arr[]`），情况不同。例如：

     ```c
     char *arr[] = {"hello", "world"}; //存储元素是字符指针的数组,数组名退化为二级指针(指向首元素地址,而且首元素是一级指针,其地址是二维指针)
     ```

     - `arr` 是一个一维数组，元素类型是 `char *`。
     - `arr` 退化为指向 `arr[0]` 的指针，即 `char **`（二级指针）。
   - 对于更高维的指针数组（如 `char **arr[]`），`arr` 会退化为 `char ***`（三级指针），以此类推。
   - 因此，指针数组的数组名退化后可能是更高阶的指针，但普通多维数组的数组名退化后始终是一级指针，只是指向的类型是低维数组。

4. **为什么不是n级指针？**：

   - 一个n维数组的数组名退化后是**一级指针**，指向(n-1)维数组的类型。
   - 要得到n级指针，通常需要定义n层指针数组，例如：

     ```c
     char ****arr; // 四级指针
     ```

     但普通n维数组（如 `int arr[2][3][4][5]`）的数组名退化后只是 `int (*)[3][4][5]`，仍然是一级指针。

5. **函数参数中的特殊情况**：
   - 当多维数组作为函数参数传递时，C语言会将数组名视为指针。例如：

     ```c
     void func(int arr[2][3][4]);
     ```

     - 在函数中，`arr` 被视为 `int (*)[3][4]`，而不是 `int[2][3][4]`。
     - 如果是指针数组 `char *arr[]`，则被视为 `char **`。

##### 示例代码

```c
#include <stdio.h>

int main() {
    int arr[2][3][4]; // 三维数组
    printf("arr = %p\n", (void *)arr); // arr 退化为 int (*)[3][4]
    printf("&arr[0] = %p\n", (void *)&arr[0]); // 相同地址
    printf("Type of arr: Use compiler to check (int (*)[3][4])\n");
    return 0;
}
```

##### 总结

- n维数组的数组名退化后是**一级指针**，指向(n-1)维数组，类型为 `Type (*)[d2][d3]...[dn]`。
- 只有在指针数组的情况下，数组名可能退化为更高阶指针（如 `char **` 或更高）。
- 因此，n维数组的数组名**不是n级指针**，而是与维度n无关的一级指针，只是指向的类型与维度相关。

### 数组指针

指向数组的指针,**偏移量为整个数组的大小**,如:

```c
int arr[20];
int (*ptr)[20]=arr; //把一维数组地址赋值一维数组指针
ptr+=1;   //指针加一,地址加20*4,即偏移量为指针指向的元素的大小80字节

//⭐⭐⭐注意:
//1.只有在ptr是完整类型的时候才可以进行ptr减法自增自减运算,否则无法确定偏移量
//2.允许int (*ptr)[]=arr;的原因是强制类型转换,把int (*)[20]类型强转为int (*)[]不完全类型
```

指向多维数组的指针偏移量相同计算方法



> [!important]
>
> 多级数组的数组名退化为首元素的地址,n维数组的数组名是n-1维数组,即需要用n-1维==**数组指针**==接收数组名,这个指针的类型是`type_t (*ptr)[len1][len2]…[len n-1]`,利用右左法则可以判断这个指针类型

```c
int (*ptrArr)[col];  //二维数组的数组指针,其指向一个长度为col的一维指针,⭐这里的col允许是变量,也可以不填,可以通过赋值数组名给ptrArr确定指向的一维数组长度,指向多维数组的指针只有第一维可以省略长度,会强转,但是这个时候这个不完全类型的指针无法确定偏移量,不能进行指针的加减运算
```

在多维数组作为形参的时候可以直接是`type_t arr[可选][col必填]`,但是数组名退化为指针,指针指向的是二维数组的元素即一维数组,所以也可以这样写`type_t (*arr)[可选]`

**==数组指针的第一维的长度都不能省略,这个时候这个指针是不完全类型的,把数组赋值给这个指针会强转,比如`int (*)[20]`类型强转为`int (*)[]`不完全类型==**



> [!warning]
>
> **把数组名赋值给数组指针的时候需要注意**
>
> - 如果数组是**静态数组(数组长度是常量)**,这个时候编译器会检查数组长度和数组指针指向的数组长度匹配与否,不匹配直接报错
> - 另一种情况是C99的变长数组,这个时候由于数组长度在编译阶段不确定,程序允许阶段才能确定,这个时候在程序运行阶段才能确定数组长度,**编译器把检查交给了程序设计者而不会报错**

```c
#include<stdio.h>
//变长数组,可以通过编译
int main()
{
    int row=3;
    int col=5;
    scanf("%d",&col);
    int arr[2][3][4]={0};
    int (*ptr)[row][col]=arr;
    return 0;
}
```

```c
#include<stdio.h>
//静态数组,编译器检测到数组长度和数组指针指向数组长度不匹配,会报错,但是如果数组指针指向的数组是VLA数组,则把检查交给程序设计者
int main()
{
    int arr[2][3][4];
    int (*ptr)[3][5]=arr; //int (*ptr)[len1][len2]=arr; 不会报错,ptr指向VLA
    return 0;
}    
```



> [!tip]
>
> 多维数组定义**只有行指标可以省略,其他长度都不能省略,**定义数组指针的时候不能省略(尽管一维数组指针可以省略长度)==省略第一维时候数组指针不能确定偏移量==
>
> ```c
> int (*ptr1)[];
> int (*ptr2)[3]; 
>     
> int (*ptr3)[][]; //编译错误,不会通过编译
> int (*ptr4)[][4];  //正确的方式
> ```
>

> [!important]
>
> **数组指针和普通数组一样可以省略第一维是==因为本质指向的是一个数组,数组在存储方式决定了可以省略第一维,最多也只能省略第一维==,但是由于指针的特性,无法确定偏移量,此时这个指针无法进行加法减法运算**,这样就把数组和数组指针统一

