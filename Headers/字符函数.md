[TOC]



# 字符分类和转换

[`cype.h`](C:\Users\Dell\Desktop\MarkDownNotes\C语言Notes\headFiles\ctype.h头文件.md "ctype.h头文件")

> C语⾔中有⼀系列的函数是专⻔做字符分类的，也就是⼀个字符是属于什么类型的字符的.这些函数的使⽤都需要包含⼀个头⽂件是 `ctype.h`

![image-20250523153209551](https://gitee.com/hulu135289/Typora/raw/master/img/20250523153209688.png)

# 字符串函数

## [`strlen`](https://en.cppreference.com/w/c/string/byte/strlen)

![image-20250524131006853](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131014018.png)

![image-20250524131026614](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131026735.png)

## [`strcpy`](https://en.cppreference.com/w/c/string/byte/strcpy)

![image-20250524131253347](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131253488.png)

![image-20250524131311078](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131311212.png)

## [`strcat`](https://en.cppreference.com/w/c/string/byte/strcat)

![image-20250524131408787](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131408928.png)

![image-20250524131523965](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131524003.png)

## [`strcmp`](https://en.cppreference.com/w/c/string/byte/strcmp)

![image-20250524131544717](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131544872.png)



## [`strncpy`](https://en.cppreference.com/w/c/string/byte/strncpy)

![image-20250524131912820](https://gitee.com/hulu135289/Typora/raw/master/img/20250524131912961.png)

![image-20250524132500225](https://gitee.com/hulu135289/Typora/raw/master/img/20250524132500309.png)

> [!important]
>
> `strncpy`加'\0'与`strcpy`有些不同 **==,`strncpy`会复制包括'\0'的字符,但是'\0'只复制一个,如果遇到'\0'但是还没达到count,则会补齐'\0',如果达到了count但是还没遇到'\0'则字符串不是'\0'结束==**

## [`strncat`](https://en.cppreference.com/w/c/string/byte/strncat)

![image-20250524133337579](https://gitee.com/hulu135289/Typora/raw/master/img/20250524133337660.png)

## [`strncmp`](https://en.cppreference.com/w/c/string/byte/strncmp)

![image-20250524155333933](https://gitee.com/hulu135289/Typora/raw/master/img/20250524155334122.png)

## [`strstr`](https://en.cppreference.com/w/c/string/byte/strstr)

![image-20250524160630018](https://gitee.com/hulu135289/Typora/raw/master/img/20250524160630196.png)

> [!tip]
>
> **查找第一次出现的位置并返回,通过判断返回值是不是NULL来检测是否找到子串**

```c
char *my_strstr(const char *str1, const char *str2)
{
    assert(str1 && str2);
    const char *str1p = str1, *str2p = str2;
    const char *ret = str1;
    while (*ret)
    {
        str1p=ret;
        str2p=str2;
        while (*str1p++ == *str2p++)
            if(!*str2p) return (char*)ret;
        ret++;
	}
    return NULL;
}
```



**拓展:**

[字符串查找算法](https://zh.wikipedia.org/wiki/字串搜尋演算法)

[$KMP$算法](https://zh.wikipedia.org/wiki/KMP算法) 

## [`strtok`](https://en.cppreference.com/w/c/string/byte/strtok)

<img src="https://gitee.com/hulu135289/Typora/raw/master/img/20250525153432643.png" alt="image-20250525153425482"  />

**代码示例**

```c
#include <stdio.h>
#include <string.h>
int main()
{
    char arr[] = "192.168.6.111";
    const char *sep = ".";
    char buf[30] = {0};
    strcpy(buf, arr); // 将arr中的字符串拷⻉到buf中，对buf的内容进⾏切割
    for (char *str = strtok(buf, sep); str != NULL; str = strtok(NULL, sep)) //⭐不确定分割次数的时候常用的处理手段
        printf("%s\n", str);
    return 0;
}
```

![image-20250525153603729](https://gitee.com/hulu135289/Typora/raw/master/img/20250525153603864.png)

> [!tip]
>
> 连续多个分隔符会把第一个修改为`'\0'`,然后跳过连续部分后续的分隔符,去把下一个分隔符改为`'\0'`
>
> ```c
> char arr[]="123...456..78.9";
> const char *str=".";
> for(const char *p=strtok(arr,str);*p!=NULL;p=strtok(NULL,str));
> //分割后字符串为"123\0..456\0.78\09"
> ```
>
> 

官方文档对[`strtok`](https://en.cppreference.com/w/c/string/byte/strtok)介绍

![image-20250602111403790](https://gitee.com/hulu135289/Typora/raw/master/img/20250602111410976.png)

![image-20250526092650310](https://gitee.com/hulu135289/Typora/raw/master/img/20250526092650390.png)

## [`strerror`](https://en.cppreference.com/w/c/string/byte/strerror)

![image-20250525163037945](https://gitee.com/hulu135289/Typora/raw/master/img/20250525163038224.png)

> [!tip]
>
> `strerror`需要包含头文件`string.h`,如果需要使用`errno`变量还需要包含头文件`errno.h`
>
> - `strerror`: 返回错误信息的字符串,后续可以`printf`打印
> - `perror`: 直接打印错误信息

### 补充:`perror`

用于打印错误信息,比`strerror`更方便的函数,`printf+error`,接收参数是打印的错误信息前面需要打印的信息(`char *`)

![image-20250526152543397](https://gitee.com/hulu135289/Typora/raw/master/img/20250526152550529.png)

```c
//示例
#include<stdio.h>
#include<errno.h>
int main()
{
    perror("error");  //现在没有错误,打印error: No error,也就是在打印的信息前面加前置需要的信息
    return 0;
}
```





**附:**字符串函数自己实现

```c
/*
	stringFun.h
*/

#include<assert.h>
#include<string.h>
#include <stdio.h>


size_t myStrlen(const char*);

char *myStrcpy(char*,const char *);

char *myStrcat(char *,const char *);

int myStrcmp(const char *,const char *);

char *myStrncpy(char *,const char *,size_t);

char *myStrncat(char*,const char *,size_t);

int myStrncmp(const char*,const char *,size_t);

char *myStrstr(const char*,const char*);

char *myStrtok(char *,const char *);
```



```c
#include"./stringFun.h"

size_t myStrlen(const char *str)
{
    assert(str);
    const char *p=str;
    while(*p++);
    return p-str-1;
}

char *myStrcpy(char *destination,const char *source)
{
    assert(destination && source);
    char *p=destination;
    while((*p++=*source++));
    return destination;
}

char *myStrcat(char *destination,const char *source)
{
    assert(destination && source);
    char *p=destination-1;
    while(*++p);
    while((*p++=*source++));
    return destination;
}

int myStrcmp(const char *str1,const char *str2)
{
    assert(str1 && str2);
    while(*str1++==*str2++)
        if(!*(str1-1)) return 0;
    return *--str1-*--str2;
}

char *myStrncpy(char* destination,const char *source,size_t n)
{
    assert(destination && source);
    char *p=destination;
    for(n++;--n && (*p++=*source++););
    while(n--) *p++=0;
    return destination;
}

char *myStrncat(char *destination,const char *source,size_t n)
{
    char *p=destination;
    while(*p++);
    for(n++,p--;--n && (*p++=*source++););
    return destination;
}

int myStrncmp(const char *str1,const char *str2,size_t n)
{
    assert(str1 && str2);
    for(n++;--n && (*str1++==*str2++);)
        if(!*(str1-1)) return 0;
    return *--str1-*--str2;
}

char *myStrstr(const char *str1,const char *str2)
{
    assert(str1 && str2);
    const char *p1=str1,*p2=str2;
    while(*str1)
    {
        p1=str1;
        p2=str2;
        while(*p1++==*p2++)
            if(!*p2) return (char*)str1;
        str1++;
    }
    return NULL;
}

char *myStrtok(char *str,const char *delim)
{
    assert(delim);
    static char *end=NULL;
    if(str) end=str;
    else str=end;

    //字符串结尾
    if(!str || !*str) return NULL;

    for(;*end;end++)
    {
        for(const char *p=delim;*p;p++)
            if(*end==*p)
            {
                *end++='\0';
                return str;
            }
    }

    //字符串末尾
    end=NULL;
    return str;
}
```

