# 浮点数类型

> [!warning]
>
> ==浮点数没有无符号类型==

- `float`占用4位字节
- `double`占用8位字节
- `long double`占用16位字节(可能占用10,12)

**==编译器处理long double类型数据的问题==**

在`stdio.h`头文件引入前面加上

```c
#define __USE_MINGE_ANSI_STDIO 1
```

即可解决问题

- 浮点数类型常量的后缀:
	- ==**`float:`**==1.0f;(==如果是0则表示为0.0f,不可以省略小数==)
	- **==`long double:`==**1.0l(==如果是0则表示为0.0l,不可以省略小数==)
	- `double`是c语言默认类型,所以不加后缀默认表示的是`double`

# 浮点数的存储方式

**在C语言中，浮点数的存储方式遵循IEEE 754标准。具体来说，C语言中的浮点数类型（如float、double）使用二进制表示，并按照IEEE 754标准进行存储。**

IEEE 754规定：
任何一个二进制浮点数`N`都可以表达成下面的方式：

$(-1) ^ S |* M |* 2 ^ E$

- 在这个式子中$(-1) ^ S$表示符号位，`当S为0时，N为正数，当S为1时，N为负数。`
- M表示的是有效位数，大于1,小于2。
- $2 ^ E$表示指数位。

> [!important]
>
> 也就是浮点数存储方式是二进制的科学计数法,将内存空间分为符号位,有效位数,指数位三部分,不同类型浮点数M,$2^E$占用位数不同,也就解释了为什么换言之类型的解读方式会导致出错,:star:而整数的数据存储都是由低到高存储和读取,即使类型不一致也只会出现溢出的问题

# 浮点数转化说明

```c
float--%f
double--%lf
long double--%Lf
科学计数法的浮点数表示中分别用%e,%le,%Le表示三种浮点数
十六进制用%a(%A),%la(%lA),%La(%LA)表示
也就是分别在f前面加l,L前缀表示double,long double类型数据
```

# 浮点数的输入

![img](https://gitee.com/hulu135289/Typora/raw/master/img/20250222150630517.jpg)

> `scanf`输入处理浮点数必须与变量的数据类型匹配(由于浮点数的特殊存储机制,类型不匹配存储在变量的数据是错误的)
>
> `scanf`先以占位符的格式读取数据,然后存储在变量的地址中,由于变量的类型与读取格式不匹配,变量在转化这个数据的时候会以变量的类型转化,导致浮点数类型不匹配存储的值差异很大
> 比如说占位符是`%f`类型存储在`double`类型变量地址中,然后会按照double类型浮点数的类型转化这个数据,但是两种浮点数存储方式不同,导致转化的时候出错
>
> 而整数类型的数据不同类型存储方式只是在高位上加位,所以类型不匹配只要不溢出就不会有问题,溢出也只是发生截断

# 浮点数的输出

==浮点数`printf`输出==

![img](https://gitee.com/hulu135289/Typora/raw/master/img/20250222153637003.jpg)

相比于`scanf`输入,`printf`浮点数的输出友好很多了,由于一些机制,在输入的时候`float`和`double`类型数据是不需要区别的,都用同一种格式说明符即可,**==但是`long double`类型还是必须匹配格式说明符==**

```c
#define __USE_MINGW_ANSI_STDIO 1
```



> ==%g占位符==
>
> - ①指数>=6或者<-4的时候：%g（%G）选择 %e（%E）输出
> - ②指数其余情况：都是选择%f输出

```c
//两个指针差值的占位符:%td
//sizeof运算符结果的占位符:%zd或%zu
```

