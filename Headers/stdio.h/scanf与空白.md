# `scanf`的空白

[`scanf`读取数据机制](scanf输入数据机制.md)

## `scanf()`占位符后面的空白

### 基本原理

在 `scanf` 函数的格式控制字符串中，除了格式说明符（如 `%d`、`%f` 等）外，普通字符（包括空白字符，如空格、制表符 `\t`、换行符 `\n`）有不同的处理规则。**当遇到空白字符时，`scanf` 会不断从输入缓冲区中读取并忽略空白字符，<font color=red>直到遇到一个非空白字符为止[^1]</font>**

### 代码示例及影响分析

以下是一个示例代码，展示了 `scanf("%d ",&n);` 的使用情况：

```c
#include <stdio.h>

int main() {
    int n;
    printf("请输入一个整数：");
    scanf("%d ", &n);
    printf("你输入的整数是：%d\n", n);
    return 0;
}
```

#### 具体影响

- **输入时**：当你输入一个整数后按下回车键，`scanf` 不会立即结束输入。因为 `%d` 会读取输入的整数，而其后的空格会让 `scanf` 继续从输入缓冲区中读取并忽略空白字符（包括你按下的回车键产生的换行符），==直到遇到一个非空白字符为止==。
- **结束输入的方式**：**你需要输入一个非空白字符（如字母、数字等），`scanf` 才会结束输入过程**。此时，这个非空白字符不会被赋值给变量 `n`，==而是会留在输入缓冲区中，供后续的输入函数读取[^2]==。

#### 示例运行情况

```plaintext
请输入一个整数：123
abc
你输入的整数是：123
```

在这个例子中，输入 `123` 后按下回车键，`scanf` 并没有结束输入，直到输入了非空白字符 `abc` 后，`scanf` 才结束，将 `123` 赋值给变量 `n`，而 `abc` 留在了输入缓冲区中。



在 `scanf` 函数的格式控制字符串中，不同格式说明符后面添加空白字符（如空格、制表符 `\t`、换行符 `\n`）的影响和原理基本是类似的，但由于不同格式说明符用于读取不同类型的数据，所以具体表现会有差异，下面分别介绍常见格式说明符后面加空白字符的情况。

### `%c` 格式说明符

`%c` 用于读取单个字符。通常情况下，它会读取输入缓冲区中的下一个字符，无论该字符是空白字符还是非空白字符。但如果在 `%c` 后面添加空白字符，情况会有所不同。

```c
#include <stdio.h>

int main() {
    char ch;
    printf("请输入一个字符：");
    scanf("%c ", &ch);
    printf("你输入的字符是：%c\n", ch);
    return 0;
}
```

#### 影响分析

当输入一个字符后按下回车键，由于 `%c` 读取了输入的字符，其后的空格会让 `scanf` 继续从输入缓冲区中读取并忽略空白字符，直到遇到一个非空白字符。这意味着你需要额外输入一个非空白字符才能让 `scanf` 结束。

```plaintext
请输入一个字符：A
B
你输入的字符是：A
```

### `%s` 格式说明符

`%s` 用于读取字符串，它会读取连续的非空白字符，直到遇到空白字符为止。在 `%s` 后面添加空白字符的影响和在 `%d` 后面添加类似。

```c
#include <stdio.h>

int main() {
    char str[100];
    printf("请输入一个字符串：");
    scanf("%s ", str);
    printf("你输入的字符串是：%s\n", str);
    return 0;
}
```

#### 影响分析

`%s` 会读取连续的非空白字符作为一个字符串，其后的空白字符会让 `scanf` 继续从输入缓冲区中读取并忽略空白字符，直到遇到一个非空白字符。所以输入一个字符串后按下回车键，`scanf` 不会结束，需要输入一个非空白字符才行。

```plaintext
请输入一个字符串：hello
world
你输入的字符串是：hello
```

### `%f`、`%lf` 格式说明符

`%f` 用于读取单精度浮点数，`%lf` 用于读取双精度浮点数。在它们后面添加空白字符的影响和 `%d` 类似。

```c
#include <stdio.h>

int main() {
    double num;
    printf("请输入一个浮点数：");
    scanf("%lf ", &num);
    printf("你输入的浮点数是：%lf\n", num);
    return 0;
}
```

#### 影响分析

输入一个浮点数后按下回车键，由于 `%lf` 读取了浮点数，其后的空白字符会让 `scanf` 继续从输入缓冲区中读取并忽略空白字符，直到遇到一个非空白字符才结束输入。

```plaintext
请输入一个浮点数：3.14
abc
你输入的浮点数是：3.140000
```

### 总结

在大多数格式说明符（如 `%d`、`%f`、`%lf`、`%s` 等）后面添加空白字符，会使 `scanf` 函数在读取完对应类型的数据后，继续忽略输入缓冲区中的空白字符，直到遇到非空白字符才结束输入。而对于 `%c` 格式说明符，它会改变原本读取下一个字符的行为，需要额外输入非空白字符来结束输入。一般来说，为了避免输入处理的复杂性，不建议在格式说明符后面随意添加空白字符。



## `scanf()`前导空白

- `scanf()`的数字的数据类型和%s会默认跳过占位符前导空白,但是%c类型不会跳过前导空白,会读取任意一个字符,此时如果不希望读取空白,可以在%c前面加一个空白(比如空格),让读取%c数据的时候进入跳过前导空白模式
- 在`scanf()`内部出现了空白,`scanf`读取下一个数据的时候会进入跳过前导空白模式,直至读取到下一个非空白字符,比如`scanf("%d ",&a)`输入1,这个时候读取到1后由于%d后面用空白,跳过前导空白,但是后面没有非空白字符,此时会停留在这个地方等待输入…

> [!warning]
>
> **==不要随便在最后加空白,不然需要输入额外的字符来结束函数`scanf`:==**
>
> 空白符结尾时，`scanf`会跳过空白符去读下一个字符，所以你必须再输入一个数

```c
scanf("%d",&a);
//输入:空格1,实际上读取的只有1存储在a的地址上,跳过了前导空白
```





[^1]:没有读入非空白不会停止这种跳过空白模式
[^2]:因为此时没有占位符让`scanf`读取到的值以赋给
