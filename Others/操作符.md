# 操作符详解

## 操作符的分类

- 算术操作符： `+ 、- 、* 、/ 、%`
- 移位操作符:` << >>`
- 位操作符: `& | ^`
- 赋值操作符:` = 、+= 、 -= 、 *= 、 /= 、%= 、<<= 、>>= 、&= 、|= 、^=`
- 单⽬操作符：` ！、++、--、&、*、+、-、~ 、sizeof、(类型)`
- 关系操作符: `> 、>= 、< 、<= 、 == 、 !=`
- 逻辑操作符：` && 、||`
- 条件操作符：` ? :`
- 逗号表达式：` ,`
- 下标调用： `[]`
- 函数调用： `()`
- 结构成员访问： `. 、->`

> 算术操作符、赋值操作符、逻辑操作符、条件操作符和部分的单⽬操作符以及很熟悉了,这部分笔记重点讲解其他几种操作符,首先补充一些前置知识

## ⼆进制原码、反码、补码

整数的2进制表⽰⽅法有三种，即原码、反码和补码有符号整数的三种表⽰⽅法均有符号位和数值位两部分，2进制序列中，最⾼位的1位是被当做符号位，剩余的都是数值位。符号位都是⽤0表⽰"正"，⽤1表⽰"负"。

![image-20250512221215278](https://gitee.com/hulu135289/Typora/raw/master/img/20250512221222489.png)

> [!tip]
>
> **正整数的原、反、补码都相同。负整数的三种表示方法各不相同。**

- **原码:**直接将数值按照正负数的形式翻译成⼆进制得到的就是原码
- **反码:**将原码的符号位不变，其他位依次按位取反就可以得到反码。(负数)
- **补码:**反码+1就得到补码。(负数)

> ==**结论:**==将补码转换为原码也是取反+1,不难用数学证明得出(设一个负数二进制数是:$a_1a_2a_3...a_n,(a_i=0,1)$计算补码讨论即可)

补充二进制原反补的意义在于计算机中存储整形数据**实际上是存储补码**以至于**==对减法操作转换为对补码加法==**

![image-20250512222056941](https://gitee.com/hulu135289/Typora/raw/master/img/20250512222056994.png)

## 移位操作符

> [!important]
>
> **==移位操作符不会改变原始数据，需要用其他变量接收结果,按位与、或、异或、取反会改变原始数据==**

```c
<< //左移操作符
>> //右移操作符
```

> [!warning]
>
> 位移操作符的操作数只能是整数,移动位数只能是**非负整数**,否则出现未定义的行为

### 左移操作符

移位规则：左边抛弃、右边补0,**相当于乘以$2^n$的操作**

```c
#include <stdio.h>
int main()
{
    int num = 10;
	int n = num << 1;
	printf("n = %d\n", n);
	printf("num = %d\n", num);
	return 0;
}
```

![左移操作符演⽰](https://gitee.com/hulu135289/Typora/raw/master/img/20250512222509774.png)

### 右移操作符

移位规则：⾸先右移运算分两种：逻辑右移,算数右移**(大部分编译器采纳第二种,需要逻辑右移强转为unsigned再移位即可)**对于**==正数相当于向0整除==$2^n$==操作,对于负数相当于向负无穷整除==**$2^n$

**一般性证明**
$$
设某一正数a=0b0a_na_{n-1}...a_1,则a>>k=0b0a_na_{n-1}...a_{k+1}=a/2^k(向0整除)\\
设某一负数b=0b1b_nb_{n-1}...b_1,b的补码(先不考虑进位)b'=0b1b'_nb'_{n-1}...(b'_1+1),\\ b'>>k=0b1b'_nb'_{n-1}...b'_{k+1},在计算b'>>k原码(取反加1,上面结论):如果b'_1=0,b_1=1\\ 不用考虑进位直接去掉后面k为取反加1即为移位后的原码,这个适合恰好是奇数(b_1=1),移位的结果是\\ 整除2^n在对负数绝对值加1,即减1,也就是向负无穷取整,如果b_1=0,偶数暂时没想到讨论方法
$$




1. 逻辑右移：左边⽤0填充，右边丢弃
2. **算术右移：左边⽤原该值的符号位填充，右边丢弃**

```c
#include <stdio.h>
int main()
{
	int num = 10;
    int n = num >> 1;
    printf("n = %d\n", n);
    printf("num = %d\n", num);
    return 0;
}
```

![逻辑右移1位演⽰](https://gitee.com/hulu135289/Typora/raw/master/img/20250512222759987.png  "逻辑右移1位演⽰")

![算术右移1位演示](https://gitee.com/hulu135289/Typora/raw/master/img/20250512222812159.png "算术右移1位演示" )

### 位操作符：`&、|、^、~`

```c
&  //按位与  	有0则0,都为1则1
|  //按位或  	有1则1,都为0则0
^  //按位异或  	不同为1,相同为0
~  //按位取反  	0变1,1变0
```

```c
//示例代码
#include <stdio.h>
int main()
{
    int num1 = -3;
    int num2 = 5;
    printf("%d\n", num1 & num2);
    printf("%d\n", num1 | num2);
    printf("%d\n", num1 ^ num2);
    printf("%d\n", ~0);
    return 0;
}
```

> **思考题**:不建立第三个变量交换两个整数
>
> ```c
> #include <stdio.h>
> int main()
> {
>     int a = 10;
>     int b = 20;
>     a = a ^ b;
>     b = a ^ b;
>     a = a ^ b;
>     printf("a = %d b = %d\n", a, b);
>     return 0;
> }
> ```
>
> 异或交换两个整数的原理：
> 1. 第一步：`a = a ^ b`  此时a中存储了a和b的异或结果
> 2. 第二步：`b = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a`  此时b的值变成了原来a的值
> 3. 第三步：`a = a ^ b = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b`  此时a的值变成了原来b的值
> 
> 利用了异或的两个特点：
> - 一个数与自身异或结果为0：`a ^ a = 0`
> - 一个数与0异或结果为其自身：`a ^ 0 = a`
> - 异或操作满足交换律和结合律：`a ^ b = b ^ a`，`(a ^ b) ^ c = a ^ (b ^ c)`

## 操作符的优先级和结合性

C语言中的操作符优先级从高到低排列如下：

| 优先级 | 操作符 | 说明 | 结合性 |
|-------|-------|------|-------|
| 1 | `()` `[]` `->` `.` | 括号、数组下标、成员访问 | 从左到右 |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `sizeof` `(类型)` | 单目运算符 | 从右到左 |
| 3 | `*` `/` `%` | 乘除模 | 从左到右 |
| 4 | `+` `-` | 加减 | 从左到右 |
| 5 | `<<` `>>` | 移位 | 从左到右 |
| 6 | `<` `<=` `>` `>=` | 关系比较 | 从左到右 |
| 7 | `==` `!=` | 相等性比较 | 从左到右 |
| 8 | `&` | 按位与 | 从左到右 |
| 9 | `^` | 按位异或 | 从左到右 |
| 10 | `|` | 按位或 | 从左到右 |
| 11 | `&&` | 逻辑与 | 从左到右 |
| 12 | `||` | 逻辑或 | 从左到右 |
| 13 | `?:` | 条件运算符 | 从右到左 |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `\|=` `<<=` `>>=` | 赋值运算符 | 从右到左 |
| 15 | `,` | 逗号运算符 | 从左到右 |

> [!tip]
> 记住优先级可以使用以下口诀：括单算移关等位逻条赋逗

## 操作符的一些实用技巧

1. **使用位运算判断奇偶数**
```c
if(num & 1) // 如果num的最低位为1，则为奇数
    printf("奇数\n");
else
    printf("偶数\n");
```

2. **不用临时变量交换整数的加减法**
```c
a = a + b;
b = a - b; // 此时b = (a+b)-b = a
a = a - b; // 此时a = (a+b)-a = b
```

3. **使用移位运算实现乘除法（提高效率）**
```c
int result = num << 3; // 等价于 num * 8
int division = num >> 2; // 等价于 num / 4
```

4. **利用异或运算实现简单加密解密**
```c
char data = 'A';
char key = 0x55;
char encrypted = data ^ key; // 加密
char decrypted = encrypted ^ key; // 解密，结果等于原始数据
```

5. **利用位运算设置或清除特定位**
```c
unsigned int value = 0x1234;
// 设置第3位（从0开始计数）
value |= (1 << 3); // 等价于 value = value | (1 << 3)
// 清除第3位
value &= ~(1 << 3); // 等价于 value = value & (~(1 << 3))
// 检查第3位是否为1
if(value & (1 << 3))
    printf("第3位是1\n");
```

